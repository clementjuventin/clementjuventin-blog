"use strict";(self.webpackChunkpersonal_website=self.webpackChunkpersonal_website||[]).push([[266],{98:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/hyperevm_daily_tx-ab99180f9688d4016c4f006371b2d2e3.png"},2519:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var i=n(9700),a=n(3420),s=n(8906);const r={slug:"building-an-arbitrager",title:"Building an Arbitrage Bot",authors:"clementjuventin",tags:[]},o=void 0,l={authorsImageUrls:[void 0]},c=[{value:"What is MEV?",id:"what-is-mev",level:2},{value:"Starting with the Basics",id:"starting-with-the-basics",level:2},{value:"Then the Real Challenge Hit",id:"then-the-real-challenge-hit",level:3},{value:"Can You Still Get Results Without a PhD Team?",id:"can-you-still-get-results-without-a-phd-team",level:2},{value:"Enter HyperEVM",id:"enter-hyperevm",level:3},{value:"The Adventure Begins",id:"the-adventure-begins",level:2},{value:"The First Proof of Concept",id:"the-first-proof-of-concept",level:3},{value:"The First Result",id:"the-first-result",level:3},{value:"Moving Toward Production",id:"moving-toward-production",level:2},{value:"HyperEVM Custom Node",id:"hyperevm-custom-node",level:3},{value:"Cold data Indexer",id:"cold-data-indexer",level:3},{value:"Solvers",id:"solvers",level:3},{value:"Monitoring",id:"monitoring",level:3},{value:"Driver",id:"driver",level:3},{value:"Offchain computation",id:"offchain-computation",level:4},{value:"Onchain computation",id:"onchain-computation",level:4},{value:"Smart Contract Module",id:"smart-contract-module",level:3},{value:"Current Results &amp; Next Steps",id:"current-results--next-steps",level:2},{value:"Final Thoughts",id:"final-thoughts",level:2}];function d(e){const t={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"I've been fascinated by MEV (Maximal Extractable Value) for a while now, and over the past few weeks, I\u2019ve started building my own arbitrage bot. It\u2019s been a challenging yet insightful journey, and I\u2019d like to share my experience so far."}),"\n",(0,a.jsx)(t.h2,{id:"what-is-mev",children:"What is MEV?"}),"\n",(0,a.jsxs)(t.p,{children:["People trade funds, people watch them trading funds, people found ways to make profits based on funds being traded.\nTo be honest, this is not today's topic, and it's a very vast field. To learn more, ",(0,a.jsx)(t.a,{href:"https://www.coingecko.com/learn/what-is-mev-maximal-extractable-value-crypto",children:"this article may help you"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"starting-with-the-basics",children:"Starting with the Basics"}),"\n",(0,a.jsxs)(t.p,{children:["To begin this adventure, I decided to explore the implementation of a ",(0,a.jsx)(t.strong,{children:"CowSwap solver"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["For those unfamiliar, ",(0,a.jsx)(t.a,{href:"https://cow.fi/cow-protocol",children:"CowSwap"})," is an off-chain order book where solvers ",(0,a.jsx)(t.strong,{children:"compete to submit the most efficient on-chain settlement"}),". Since all solvers use the same underlying liquidity sources, the competition lies less in speed or on-chain monitoring tricks, and more in ",(0,a.jsx)(t.strong,{children:"algorithmic quality"})," (from what I understand)."]}),"\n",(0,a.jsx)(t.p,{children:"I figured this would be a great way to get hands-on experience with arbitrage using real-world tools, while also learning from the CowSwap ecosystem itself."}),"\n",(0,a.jsxs)(t.p,{children:["Unfortunately, that turned out to be a bit optimistic. The competitiveness of an arbitrage system is deeply tied to its performance \u2014 which means that sharing strategies often ",(0,a.jsx)(t.strong,{children:"undermines profitability"}),". So, I quickly realized that there wouldn\u2019t be much help available when it came to solving the core problems."]}),"\n",(0,a.jsx)(t.p,{children:"That said, I followed CowSwap\u2019s documentation closely and was able to get the full local stack up and running, including syncing with the live order book."}),"\n",(0,a.jsxs)(t.p,{children:["I chose to implement my solver in ",(0,a.jsx)(t.strong,{children:"C++"})," \u2014 for once, it wasn\u2019t overkill. I was surprised to find I was already familiar with many of the liquidity models: ",(0,a.jsx)(t.strong,{children:"Uniswap V2/V3"}),", ",(0,a.jsx)(t.strong,{children:"Balancer\u2019s stable and weighted pools"}),", and a few others. The remaining pool types seemed negligible."]}),"\n",(0,a.jsx)(t.h3,{id:"then-the-real-challenge-hit",children:"Then the Real Challenge Hit"}),"\n",(0,a.jsxs)(t.p,{children:["The complexity came when I had to actually ",(0,a.jsx)(t.strong,{children:"write the algorithm"})," \u2014 and I had no clear direction. Neither the documentation nor any online resource offered much guidance."]}),"\n",(0,a.jsx)(t.p,{children:"An ideal solver algorithm would likely involve:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Graph theory"}),", to identify optimal trade paths"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Game theory"}),", to balance solver profitability with order competitiveness"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Mathematical modeling"}),", to simulate off-chain liquidity movements"]}),"\n",(0,a.jsxs)(t.li,{children:["Handling ",(0,a.jsx)(t.strong,{children:"limit orders"}),", ",(0,a.jsx)(t.strong,{children:"partial orders"}),", and other edge cases"]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["In short, this problem is likely ",(0,a.jsx)(t.strong,{children:"NP-complete"}),", requiring advanced algorithms and a deep mathematical foundation. I had just thrown myself headfirst into the deep end of arbitrage complexity."]}),"\n",(0,a.jsx)(t.h2,{id:"can-you-still-get-results-without-a-phd-team",children:"Can You Still Get Results Without a PhD Team?"}),"\n",(0,a.jsxs)(t.p,{children:["That\u2019s the question I began asking myself. Is it possible to ",(0,a.jsx)(t.strong,{children:"simplify the problem"})," and/or ",(0,a.jsx)(t.strong,{children:"reduce the level of competition"}),"? It was clear that I had no chance to compete with the big players, even after a few months of development."]}),"\n",(0,a.jsxs)(t.p,{children:["One idea came to mind: target a ",(0,a.jsx)(t.strong,{children:"newer blockchain"})," \u2014 one that\u2019s less mature in terms of ecosystem and developer tooling. That would mean less competition, and maybe a better learning ground."]}),"\n",(0,a.jsx)(t.h3,{id:"enter-hyperevm",children:"Enter HyperEVM"}),"\n",(0,a.jsxs)(t.p,{children:["My search led me to ",(0,a.jsx)(t.strong,{children:"HyperEVM"}),", a relatively new EVM-compatible blockchain developed by ",(0,a.jsx)(t.a,{href:"https://hyperliquid.gitbook.io/hyperliquid-docs",children:(0,a.jsx)(t.strong,{children:"Hyperliquid"})}),". It felt like stepping into the Wild West."]}),"\n",(0,a.jsxs)(t.p,{children:["Why ",(0,a.jsx)(t.strong,{children:"HyperEVM"})," was promising:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.strong,{children:"Low gas fees"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.strong,{children:"Modest but exploitable trading volume"})}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"EVM compatibility"})," (making integration much easier)"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Fewer active arbitrage bots"}),", due to its early-stage ecosystem"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"So I began roughing out a system that could serve as an arbitrage bot on this new chain. I\u2019ll describe the different directions I explored to improve the bot\u2019s profitability. I experimented as much as I could and tried to learn by doing, testing every idea that seemed viable."}),"\n",(0,a.jsx)(t.h2,{id:"the-adventure-begins",children:"The Adventure Begins"}),"\n",(0,a.jsx)(t.p,{children:"Choosing an EVM-compatible chain seemed like a great idea \u2014 in theory, it would allow me to port this system to any other EVM-compatible chain later on. In practice, though, things turned out to be more complicated due to protocols specificities."}),"\n",(0,a.jsx)(t.h3,{id:"the-first-proof-of-concept",children:"The First Proof of Concept"}),"\n",(0,a.jsx)(t.p,{children:"To build my proof of concept (PoC), I needed a few key components:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Fast access to on-chain data"}),"\n",(0,a.jsx)(t.li,{children:"Off-chain liquidity simulation for Uniswap-like pools"}),"\n",(0,a.jsx)(t.li,{children:"The ability to send on-chain transactions with protection against slippage"}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["I started with a ",(0,a.jsx)(t.strong,{children:"QuickNode RPC"}),", but quickly hit the 200 requests/sec limit. That capped me at monitoring roughly 30 pools during testing."]}),"\n",(0,a.jsxs)(t.p,{children:["I integrated ",(0,a.jsx)(t.a,{href:"https://hyperswap.exchange/",children:(0,a.jsx)(t.strong,{children:"Hyperswap"})})," and ",(0,a.jsx)(t.a,{href:"https://kittenswap.finance/",children:(0,a.jsx)(t.strong,{children:"Kittenswap"})}),", the two most active DEXs on ",(0,a.jsx)(t.strong,{children:"HyperEVM"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"My first approach, somewhat naive, was to look for arbitrage loops that start and end with the same token. That way, there's no need to rely on price approximations (e.g., A \u2192 B \u2192 A or A \u2192 B \u2192 C \u2192 A). I deployed a smart contract capable of executing multiple swaps and reverting if the final balance was lower than the initial one. This ensure that the bot will never spend more than it earns."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:'function execute(\n    Trade[] calldata trades,\n    uint256 amountIn,\n    address startToken\n) external payable returns (uint256) {\n    uint256 balanceBefore = IERC20(startToken).balanceOf(address(this));\n\n    // ... perform trades ...\n\n    uint256 balanceAfter = IERC20(startToken).balanceOf(address(this));\n    // This line will revert all the previous operations and stop the execution\n    require(balanceAfter > balanceBefore, "Arbitrage failed");\n\n    return balanceAfter - balanceBefore;\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"In TypeScript, I implemented functions to compute expected token outputs for Uniswap V2 and approximated Uniswap V3 swaps \u2014 V3 is more complex due to its tick system while V2 is pretty straightforward."}),"\n",(0,a.jsx)(t.p,{children:"To detect arbitrage opportunities, I wrote a simple brute force algorithm that computes the best arbitrage path for a given input amount."}),"\n",(0,a.jsx)(t.p,{children:"I decided to hardcode the input amount to 1 HYPE, and to ignore the gas cost of the transaction because it was extremely low at the time."}),"\n",(0,a.jsx)(t.h3,{id:"the-first-result",children:"The First Result"}),"\n",(0,a.jsxs)(t.p,{children:["With everything wired up, I ran the bot, stepped away for 20 minutes\u2026 and came back to see my ",(0,a.jsx)(t.strong,{children:"first profitable transaction \u2014 about $0.30"})," at the time."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"First Arbitrage Transaction",src:n(7106).A+"",width:"1044",height:"248"})}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:["My first arbitrage transaction on HyperEVM. Source ",(0,a.jsx)(t.a,{href:"https://purrsec.com/tx/0x710e7c9dd53dad1aa3cb15b3225eb1b777a3b230a750e4a36f1d4eb9de17e87e",children:"Purrsec"}),"."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"It was a small gain, but a huge morale boost. At that point, I believed I was close to a viable system. With a dedicated node and estimated infrastructure costs around $100/month, profitability seemed achievable."}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Spoiler"}),": I still had a long road ahead. Competition would ramp up quickly in the days to come. But in hindsight, that initial optimism was crucial \u2014 if I had only focused on the months of work and potential financial losses ahead, I might have stopped right there."]}),"\n",(0,a.jsx)(t.h2,{id:"moving-toward-production",children:"Moving Toward Production"}),"\n",(0,a.jsx)(t.p,{children:"So far, here's a diagram of my architecture \u2014 each module is explained below."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Architecture",src:n(4138).A+"",width:"1167",height:"598"})}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"Colors are just here to make things prettier \ud83d\udc4c\u200b."}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"hyperevm-custom-node",children:"HyperEVM Custom Node"}),"\n",(0,a.jsxs)(t.p,{children:["My first step toward production was setting up ",(0,a.jsx)(t.strong,{children:"a local node"}),". This gave me full on-chain access with low latency and no rate limits. I didn't follow the advice from the documentation, which recommended using a node in Japan to reduce latency issues, even though it was cheaper in the US. I eventually switched and ended up losing several days syncing the node with a machine in Tokyo due to latency issues."]}),"\n",(0,a.jsx)(t.h3,{id:"cold-data-indexer",children:"Cold data Indexer"}),"\n",(0,a.jsxs)(t.p,{children:["I needed a way to cache persistent data (e.g., token names, decimals, pool tokens). So I wrote an ",(0,a.jsx)(t.strong,{children:"indexer that stores data in Redis"}),", refreshed periodically."]}),"\n",(0,a.jsx)(t.h3,{id:"solvers",children:"Solvers"}),"\n",(0,a.jsxs)(t.p,{children:["Each solver receives a request from the driver and solves a graph to find arbitrage paths. Initially, this logic was in ",(0,a.jsx)(t.strong,{children:"JavaScript"})," for rapid prototyping. Later, I migrated to ",(0,a.jsx)(t.strong,{children:"C++"}),", which was 80x faster on average \u2014 crucial when tracking many pools. It is the same brute force algorithm I used in the PoC."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:'inline void find_best_arbitrage_cycle(\n    const std::vector<std::vector<const Api::LiquidityPoolTradePath *>> &all_cycles,\n    const Api::uint256 amount_in, \n    Api::uint256 &best_amount_out,\n    std::vector<const Api::LiquidityPoolTradePath *> &best_cycle\n    ) {\n  for (const auto &cycle : all_cycles) {\n    try {\n      const Api::uint256 amount_out = compute_cycle_amount_out(cycle, amount_in);\n\n      if (amount_out > best_amount_out) {\n        best_amount_out = amount_out;\n        best_cycle = cycle;\n      }\n\n    } catch (Math::InvalidLiquidityStateError &e) {\n      continue;\n    } catch (const std::exception &e) {\n      std::cout << "Error: " << e.what() << std::endl;\n    }\n  }\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"Note that I was heavily inspired by CowSwap. It was important for me to design the system with multiple solvers from the start, as this would allow for horizontal scaling of the solving process, as well as safe comparison of different algorithms \u2014 since each solution is evaluated and put in competition with the others."}),"\n",(0,a.jsx)(t.h3,{id:"monitoring",children:"Monitoring"}),"\n",(0,a.jsxs)(t.p,{children:["To monitor performance, I built a metrics indexer that feeds ",(0,a.jsx)(t.strong,{children:"Prometheus"}),", which powers ",(0,a.jsx)(t.strong,{children:"Grafana"})," dashboards."]}),"\n",(0,a.jsx)(t.p,{children:"To be honest, I under-invested here. I'm still missing key insights and can\u2019t precisely track profit/loss over time. The idea was to compare strategies and versions of the arbitrage engine, but I\u2019ve mostly been busy building essential features."}),"\n",(0,a.jsx)(t.p,{children:"You can see in the following screenshot that this allows me to visualize the increase in the contract's balances (due to arbitrage activity) and the amount of HYPE available to cover transaction fees for the wallets responsible for calling the arbitrageur."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Grafana dashboard",src:n(4255).A+"",width:"1098",height:"763"})}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"Grafana dashboard (with a bug regarding BTC decimals)."}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"driver",children:"Driver"}),"\n",(0,a.jsxs)(t.p,{children:["I built a central coordination module called the ",(0,a.jsx)(t.strong,{children:"Driver"})," (also inspired by CowSwap\u2019s architecture). It\u2019s responsible for:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"High-frequency data collection"}),"\n",(0,a.jsx)(t.li,{children:"Structuring the data into a standard request format"}),"\n",(0,a.jsx)(t.li,{children:"Sending requests to all available solvers"}),"\n",(0,a.jsx)(t.li,{children:"Collecting and evaluating responses within a strict timeout"}),"\n",(0,a.jsx)(t.li,{children:"Comparing the results to determine the best solver and submit the transaction"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Simulating gas cost and submitting transactions reliably was another challenge. I eventually introduced a dynamic fee deduction, setting aside a portion of profit to cover validator fees and ensure transaction inclusion. I am still not convinced with this approach, but I have no better idea for now."}),"\n",(0,a.jsx)(t.p,{children:"Thanks to the strategy of using multiple solvers, I was able to narrow down the list of cryptocurrencies used to initiate arbitrage cycles. This increases the number of opportunities, as it allows for shorter arbitrage loops."}),"\n",(0,a.jsx)(t.p,{children:"For example, a cycle like A \u2192 B \u2192 C \u2192 B \u2192 A can be shortened to B \u2192 C \u2192 B, saving two transactions if the contract already holds B."}),"\n",(0,a.jsx)(t.p,{children:"Responses are evaluated and filtered \u2014 in the PoC, I hardcoded the input token amount to 1 HYPE, which was suboptimal. Profits vary significantly depending on input size."}),"\n",(0,a.jsx)(t.p,{children:"To omptimize the input size estimation, I tried different strategies:"}),"\n",(0,a.jsx)(t.h4,{id:"offchain-computation",children:"Offchain computation"}),"\n",(0,a.jsxs)(t.p,{children:["Off-chain calculation is fast and reliable \u2014 if you have accurate models and complete data. For Uniswap V2, the math is simple. For V3, it\u2019s ",(0,a.jsx)(t.a,{href:"https://uniswapv3book.com/index.html",children:(0,a.jsx)(t.strong,{children:"evil"})}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["In the PoC, I used a rough approximation to avoid tick-level math. To compute real outputs with Uniswap V3's SDK, you need ",(0,a.jsx)(t.strong,{children:"all tick data"}),", which is extremely resource-intensive \u2014 even with a private node."]}),"\n",(0,a.jsx)(t.p,{children:"My idea was to fetch a subset of ticks because arbitrage transactions are often low-volume. I managed to code the math but the delays were still significant when it came to fetch the data. I finally gave up this approach for the next strategy."}),"\n",(0,a.jsx)(t.h4,{id:"onchain-computation",children:"Onchain computation"}),"\n",(0,a.jsx)(t.p,{children:"Instead of fully computing everything off-chain, I opted for a hybrid approach:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Approximate swaps using a constant-tick assumption (ie. Uniswap V3 math approximation)"}),"\n",(0,a.jsx)(t.li,{children:"Collect all promising trade paths"}),"\n",(0,a.jsx)(t.li,{children:"Simulate each candidate on-chain via a custom smart contract (a read-only call)"}),"\n",(0,a.jsx)(t.li,{children:"Use binary search (dichotomy) to find the input amount that maximizes profit"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"This approach is based on the fact that the data is available, but communication between the driver and the node results in significant latency. Even when both programs run on the same machine, each request still has to go through the full network stack. Since tick retrieval can't be properly parallelized, fetch times become a bottleneck."}),"\n",(0,a.jsx)(t.p,{children:"Instead, the node is tasked with simulating a smart contract execution. This way, it uses the same math as the actual contracts (eliminating the risk of errors) and has direct, optimized access to its own data."}),"\n",(0,a.jsxs)(t.p,{children:["This gave me much better results while avoiding heavy off-chain computation. Here is a snippet of the binary search function, it returns the optimal ",(0,a.jsx)(t.code,{children:"k"})," value (ie. the best amount) to maximize the profit:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sol",children:"function binarySearchOptimalK(\n    Trade[] calldata trades,\n    uint256 step,\n    uint256 balance\n) internal returns (uint256) {\n    uint256 low_k = 1;\n    uint256 high_k = balance / step;\n    while (low_k < high_k) {\n        uint256 mid_k = low_k + (high_k - low_k) / 2;\n        uint256 profitMid = computeTradesProfit(\n            trades,\n            mid_k * step\n        );\n        uint256 profitNext = computeTradesProfit(\n            trades,\n            (mid_k + 1) * step\n        );\n        if (profitMid >= profitNext) {\n            high_k = mid_k;\n        } else {\n            low_k = mid_k + 1;\n        }\n    }\n    return low_k;\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["And this is ",(0,a.jsx)(t.strong,{children:"costless"})," because I am ",(0,a.jsx)(t.strong,{children:"simulating"})," this call (even though it's a write function)."]}),"\n",(0,a.jsx)(t.h3,{id:"smart-contract-module",children:"Smart Contract Module"}),"\n",(0,a.jsx)(t.p,{children:"My first smart contract was simple, and it worked well initially.\nThe main purpose is to prevent the bot to concretely loose funds (e.g. Spend 1 A and obtain 0.98 A)."}),"\n",(0,a.jsxs)(t.p,{children:["But as my whole bot system matured, it became clear that the contract was ",(0,a.jsx)(t.strong,{children:"critical to profitability"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["Profit calculation is straightforward: ",(0,a.jsx)(t.code,{children:"profit = total_output - total_input - gas_cost"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"But when a transaction fails, you still pay the gas \u2014 often due to a competing bot front-running your trade.\nThese failed transactions became increasingly costly due to the gas price increasing of a ~500x factor (HyperEVM became more popular)."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"HyperEVM daily transactions",src:n(98).A+"",width:"934",height:"562"})}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:["HyperEVM daily transactions. Source ",(0,a.jsx)(t.a,{href:"https://purrsec.com/trending/metrics",children:"Purrsec"}),"."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"To mitigate this:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"I optimized gas usage with basic Solidity gas optimizations"}),"\n",(0,a.jsxs)(t.li,{children:["Introduced an early-exit condition before the final balance comparison (",(0,a.jsx)(t.code,{children:"balanceAfter < balanceBefore"}),")"]}),"\n",(0,a.jsx)(t.li,{children:"Tweaked execution to minimize unnecessary operations"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"This lowered the average cost per trade significantly, but not enough."}),"\n",(0,a.jsx)(t.h2,{id:"current-results--next-steps",children:"Current Results & Next Steps"}),"\n",(0,a.jsx)(t.p,{children:"As of now, the bot is not yet profitable. On average, I recover only ~80% of the input."}),"\n",(0,a.jsx)(t.p,{children:"To bridge the gap to profitability, I have two main ideas:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Reduce fees further"}),"\n",(0,a.jsx)(t.li,{children:"Use heuristics to detect and avoid unprofitable trades"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"The second option seems most promising \u2014 I haven\u2019t explored it yet, and it requires a larger dataset to analyze trade outcomes at scale. I'll need to analyze all trades performed and hopefully find patterns that reduce the number of failed transactions."}),"\n",(0,a.jsxs)(t.p,{children:["Also, I face a new challenge: ",(0,a.jsx)(t.strong,{children:"latency"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Block time on HyperEVM has dropped to under 1 second (2 seconds originally). Because my experiments run from a machine in US, network latency to the HyperEvm sequencers (hosted in Tokyo) is hurting my competitiveness."}),"\n",(0,a.jsx)(t.p,{children:"I\u2019ll need a new setup \u2014 ideally a server located closer to the sequencer region \u2014 to reduce latency and stay in sync."}),"\n",(0,a.jsx)(t.h2,{id:"final-thoughts",children:"Final Thoughts"}),"\n",(0,a.jsx)(t.p,{children:"There\u2019s still a long road ahead, but I believe it\u2019s worth it. I\u2019ve learned a ton about arbitrage, on-chain mechanics, and smart contract optimization \u2014 and I\u2019m only getting started."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},4138:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/arbitrager_archi-6bd40f6f2dbd597645e6e6a2a3bef9c4.png"},4255:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/arbitrager_dashboard-1a12f4d1c7a4d4161f3be43d77919c3d.png"},7106:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/first_arbitrage_tx-e91e9886c9e4027798c09a7a6711b8cb.jpg"},8906:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var i=n(6672);const a={},s=i.createContext(a);function r(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:t},e.children)}},9700:e=>{e.exports=JSON.parse('{"permalink":"/clementjuventin-blog/building-an-arbitrager","source":"@site/blog/2025-06-03-building-an-arbitrager.md","title":"Building an Arbitrage Bot","description":"I\'ve been fascinated by MEV (Maximal Extractable Value) for a while now, and over the past few weeks, I\u2019ve started building my own arbitrage bot. It\u2019s been a challenging yet insightful journey, and I\u2019d like to share my experience so far.","date":"2025-06-03T00:00:00.000Z","tags":[],"readingTime":11.9,"hasTruncateMarker":true,"authors":[{"name":"Cl\xe9ment Juventin","title":"Internet traveler \ud83e\udd16\u200b","url":"https://linkedin.com/in/cl\xe9ment-juventin-ab81841a3/","page":{"permalink":"/clementjuventin-blog/authors/clementjuventin"},"socials":{"linkedin":"https://www.linkedin.com/in/clementjuventin/","github":"https://github.com/clementjuventin"},"imageURL":"https://github.com/clementjuventin.png","key":"clementjuventin"}],"frontMatter":{"slug":"building-an-arbitrager","title":"Building an Arbitrage Bot","authors":"clementjuventin","tags":[]},"unlisted":false,"nextItem":{"title":"From A Nooby Degen to a Bloodthirsty Sniper","permalink":"/clementjuventin-blog/degen-to-sniper"}}')}}]);