"use strict";(self.webpackChunkpersonal_website=self.webpackChunkpersonal_website||[]).push([[89],{4002:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/reward_curve-dfecc95cef03ff4782a8a2ad48fd5049.png"},5643:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/reward_curve_complex-a1f46dc1930dae94befbad4d294bc27f.png"},6946:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});var i=t(9707),a=t(3420),o=t(8906);const r={slug:"opal-technical-overview",title:"Opal - Technical Overview",authors:"clementjuventin",tags:["opal","technical","web3"]},s=void 0,l={authorsImageUrls:[void 0]},d=[{value:"Protocol Overview",id:"protocol-overview",level:2},{value:"The Omnipool",id:"the-omnipool",level:2},{value:"The Reward Manager",id:"the-reward-manager",level:2},{value:"Modeling and Distributing Rewards",id:"modeling-and-distributing-rewards",level:3},{value:"Implementation",id:"implementation",level:3},{value:"Toward a More Concrete Example",id:"toward-a-more-concrete-example",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["In this article, I\u2019ll dive into the ",(0,a.jsx)(n.strong,{children:"technical underpinnings of the Opal protocol"}),", a project I\u2019ve contributed to extensively. If you haven\u2019t yet read the previous article about Opal, I recommend starting ",(0,a.jsx)(n.a,{href:"/clementjuventin-blog/opal",children:"there"})," to better understand the context of what follows."]}),"\n",(0,a.jsxs)(n.p,{children:["Here, we\u2019ll focus on two of the protocol\u2019s most important smart contracts: the ",(0,a.jsx)(n.strong,{children:"Omnipool"})," and the ",(0,a.jsx)(n.strong,{children:"Reward Manager"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"The Omnipool is the core of the protocol\u2014it\u2019s a single-asset liquidity pool that can dynamically rebalance and reallocate funds across different strategies. It lies at the heart of Opal\u2019s yield-generation mechanism and represents the foundation of the platform's financial logic."}),"\n",(0,a.jsx)(n.p,{children:"The second contract, the Reward Manager, is one I developed almost entirely independently. Its role is to handle the distribution of rewards to users participating in the Omnipool. I find the mathematical model behind it particularly elegant and effective. While similar systems are likely common and well-studied in DeFi, in this article, we\u2019ll take a closer look at Opal\u2019s unique implementation."}),"\n",(0,a.jsx)(n.h2,{id:"protocol-overview",children:"Protocol Overview"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Protocol Overview",src:t(7404).A+"",width:"902",height:"510"})}),"\n",(0,a.jsxs)(n.p,{children:["This diagram is a simplified version of the Opal protocol, highlighting the ",(0,a.jsx)(n.strong,{children:"flow of liquidity and rewards"})," managed by the protocol."]}),"\n",(0,a.jsx)(n.p,{children:"The typical operation of an omnipool is as follows:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"For an omnipool that accepts an underlying asset A, the governance module proposes a set of pools along with a distribution weight for the liquidity."}),"\n",(0,a.jsx)(n.li,{children:"Liquidity deposited into the omnipool is allocated according to these weights."}),"\n",(0,a.jsx)(n.li,{children:"If the current underlying pool weights deviate from those voted by the governance module, an incentive in GEM (the governance token) is distributed to reward rebalancing. The pool weights represents the relative share of the liquidity allocated to each underlying pool."}),"\n",(0,a.jsx)(n.li,{children:"Over time, the omnipool accrues rewards, which are tracked by the Reward Manager."}),"\n",(0,a.jsx)(n.li,{children:"When a user withdraws their liquidity or chooses to claim their rewards, the Reward Manager distributes the appropriate amount."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"the-omnipool",children:"The Omnipool"}),"\n",(0,a.jsxs)(n.p,{children:["Let\u2019s start by examining the main method of the omnipool: ",(0,a.jsx)(n.strong,{children:"the deposit method"}),"."]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"As a general note for this article: in all code snippets, I systematically remove uninteresting sections such as parameter validation to improve readability."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"function depositFor(uint256 _amountIn, address _depositFor, uint256 _minLpReceived) public {\n    // Get the price of the underlying asset in USD\n    uint256 underlyingPrice = oracle.getUSDPrice(address(underlyingToken));\n\n    // Estimate the value in USD of the liquidity in the omnipool before the deposit\n    uint256 beforeTotalUnderlying = _getTotalAndPerPoolUnderlying(underlyingPrice);\n    \n    // Transfer underlying token to this contract\n    underlyingToken.safeTransferFrom(msg.sender, address(this), _amountIn);\n\n    // Estimate the current exchange rate of the omnipool (ie. how much LP tokens are minted for each underlying token deposited)\n    uint256 exchangeRate = _exchangeRate(beforeTotalUnderlying);\n\n    // Deposit into Aura Finance (and Balancer V2)\n    _depositToAura(beforeTotalUnderlying, _amountIn);\n\n    // Estimate the new value of the liquidity in the omnipool after the deposit\n    uint256 afterTotalUnderlying = _getTotalAndPerPoolUnderlying(underlyingPrice);\n\n    // Calculate the increase in the value of the liquidity in the omnipool\n    uint256 underlyingBalanceIncrease = afterTotalUnderlying - beforeTotalUnderlying;\n\n    // Calculate the amount of LP tokens that can be minted\n    uint256 mintableUnderlyingAmount = _min(_amountIn, underlyingBalanceIncrease);\n    uint256 lpReceived = mintableUnderlyingAmount.divDown(exchangeRate);\n\n    // Slippage protection\n    if (lpReceived < _minLpReceived) {\n        revert TooMuchSlippage();\n    }\n    lpToken.mint(_depositFor, lpReceived, _depositFor);\n\n    // Handle rebalancing rewards\n    _handleRebalancingRewards(...);\n\n    // Emit an event to notify the outside world\n    emit Deposit(_depositFor, _amountIn, lpReceived);\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You'll immediately notice a key feature of contracts dealing with omnipools: ",(0,a.jsx)(n.strong,{children:"everything is denominated in USD"}),", thanks to oracles.\nIndeed, to maintain a fair balance across multiple underlying pools, it's absolutely essential to ",(0,a.jsx)(n.strong,{children:"accurately price the current value of all positions held by the omnipool"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Opal relies heavily on oracle usage. Every token in every underlying pool must have a reliable price oracle."}),"\n",(0,a.jsxs)(n.p,{children:["This introduces a natural limitation: ",(0,a.jsx)(n.strong,{children:"it's not possible to farm liquidity pools with low market cap tokens"}),", as they often lack trustworthy oracles. Generally, these tokens offer higher APRs because they carry more risk. It's unfortunate to miss out on such opportunities, but this restriction is necessary to ensure the protocol\u2019s overall security."]}),"\n",(0,a.jsxs)(n.p,{children:["To conclude on the oracle topic, note that Opal is restricted to use ",(0,a.jsx)(n.a,{href:"https://data.chain.link/streams",children:"Chainlink"})," and ",(0,a.jsx)(n.a,{href:"https://app.redstone.finance/app/tokens/?tokenTypes=crypto",children:"Redstone"})," feeds. These lists define the full range of tokens eligible for integration into new underlying pools."]}),"\n",(0,a.jsx)(n.p,{children:"To estimate the value of a position held by the omnipool, we rely on:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"the USD price of each token forming the underlying Balancer pool, and"}),"\n",(0,a.jsx)(n.li,{children:"the math provided in the Balancer documentation, which governs pool behavior."}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://github.com/balancer/docs/blob/main/docs/concepts/advanced/valuing-bpt/valuing-bpt.md#on-chain-price-evaluation",children:"This document"})," provides a detailed explanation of the math used to estimate the value of a Balancer Pool Token (BPT)."]}),"\n",(0,a.jsxs)(n.p,{children:["As for the rest, I won\u2019t go deeper into the omnipool methods in this article.\nHowever, if you're interested in exploring the full implementation, the smart contract code is publicly available on ",(0,a.jsx)(n.a,{href:"https://etherscan.io/address/0x50953a9842b1fe42db077f1b850ec365a25f9d8e#code",children:"Etherscan"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"the-reward-manager",children:"The Reward Manager"}),"\n",(0,a.jsxs)(n.p,{children:["Let\u2019s now discuss the ",(0,a.jsx)(n.strong,{children:"Reward Manager"})," \u2014 a key module responsible for distributing rewards to users."]}),"\n",(0,a.jsxs)(n.p,{children:["More specifically, the rewards accumulated by the omnipool are distributed by Balancer and Aura Finance in the form of their respective governance tokens: ",(0,a.jsx)(n.code,{children:"BAL"})," and ",(0,a.jsx)(n.code,{children:"AURA"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["In some cases, external protocols may incentivize users to provide liquidity by offering extra rewards. These are one-off or special tokens distributed in addition to ",(0,a.jsx)(n.code,{children:"BAL"})," and ",(0,a.jsx)(n.code,{children:"AURA"}),". For simplicity, the following examples focus only on handling ",(0,a.jsx)(n.code,{children:"BAL"})," tokens, but the logic can be duplicated to support any other reward token."]}),"\n",(0,a.jsx)(n.p,{children:"It\u2019s also worth noting a crucial difference from Uniswap:\nIn Uniswap, a liquidity pool A/B typically distributes claimable rewards in both token A and B.\nIn Balancer V2, however, profits are directly reinvested into the BPT (Balancer Pool Tokens), increasing their intrinsic value."}),"\n",(0,a.jsx)(n.p,{children:"This means there\u2019s no need to redistribute LP token rewards \u2014 only the reward tokens emitted by the underlying protocols integrated into Opal."}),"\n",(0,a.jsx)(n.h3,{id:"modeling-and-distributing-rewards",children:"Modeling and Distributing Rewards"}),"\n",(0,a.jsxs)(n.p,{children:["Before diving into the code, let\u2019s break down the ",(0,a.jsx)(n.strong,{children:"mathematical model"})," behind reward accumulation and distribution."]}),"\n",(0,a.jsx)(n.p,{children:"To accurately track the rewards accrued by the omnipool over time, we use a mathematical integral \u2014 denoted as R (for Rewards). An integral is monotonic and non-decreasing, which perfectly matches our use case:"}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"The omnipool can only accumulate rewards over time, never lose them."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"To be more precise, R expresses the values of one unit of LP token in the omnipool over time."}),"\n",(0,a.jsx)(n.p,{children:"As a simplified example, imagine a linear curve representing R over time \u2014 a case where the omnipool receives a constant flow of rewards and is updated at each block:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Rewards Curve",src:t(4002).A+"",width:"1200",height:"800"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"R(t) = constant \xd7 t"})," (very simple case). Source Desmos."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["When a user joins the omnipool, we need to store the value ",(0,a.jsx)(n.code,{children:"R(t)"})," at that moment, representing the accumulated rewards before their participation."]}),"\n",(0,a.jsx)(n.p,{children:"When the user decides to claim their rewards, we simply:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Retrieve the current reward state ",(0,a.jsx)(n.code,{children:"R(t+1)"})]}),"\n",(0,a.jsxs)(n.li,{children:["Subtract the value at their join time ",(0,a.jsx)(n.code,{children:"R(t)"})]}),"\n",(0,a.jsxs)(n.li,{children:["Compute the reward delta: ",(0,a.jsx)(n.code,{children:"reward = R(t+1) - R(t)"})]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["This delta is always \u2265 0 and represents the rewards accrue by one unit of the LP token in the omnipool at ",(0,a.jsx)(n.code,{children:"t+1"})," minus the value at ",(0,a.jsx)(n.code,{children:"t"}),"."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Rewards Curve User",src:t(7574).A+"",width:"1200",height:"800"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["On this diagram, ",(0,a.jsx)(n.code,{children:"t=5"})," and ",(0,a.jsx)(n.code,{children:"t+1=10"}),". The rewards accrued by one unit of the LP token in the omnipool between ",(0,a.jsx)(n.code,{children:"t"})," and ",(0,a.jsx)(n.code,{children:"t+1"})," is ",(0,a.jsx)(n.code,{children:"R(t+1) - R(t) = 10 - 5 = 5"}),". Source Desmos."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Now, the remaining step is to distribute the rewards among liquidity providers proportionally to their share in the pool. This share is known, as it directly corresponds to their current balance. The final formula is:"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"reward = balance * (R(t+1) - R(t))"})," (we don't see ",(0,a.jsx)(n.code,{children:"totalSupply"})," in the formula because it's contained in ",(0,a.jsx)(n.code,{children:"R"}),")."]}),"\n",(0,a.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,a.jsxs)(n.p,{children:["Now that we have been through the mathematical model, let's take a look at the ",(0,a.jsx)(n.code,{children:"updateUserState"})," function, which is called whenever a user deposits or claims rewards. It updates both the global omnipool state and the individual user\u2019s reward data:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"function updateUserState(address _account) public {\n    // Get the user's LP balance\n    uint256 deposited = omnipool.balanceOf(_account);\n\n    // Update the pool state, claim rewards, and transfer them to the Reward Manager\n    _updateOmnipoolState();\n\n    // Update the user's pending rewards\n    _updateRewards(_account, deposited);\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The logic is straightforward, let's see what's inside of ",(0,a.jsx)(n.code,{children:"_updateOmnipoolState"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"function _updateOmnipoolState() internal {\n    // Claim rewards accrued from underlying protocols\n    uint256 earnedBAL = _claimOmnipoolRewards();\n\n    // Get the total amount of LP tokens deposited into the omnipool\n    uint256 totalDeposited = omnipool.totalSupply();\n\n    // Update the global reward state\n    BALMeta.earnedIntegral += (earnedBAL * SCALED_ONE) / totalDeposited;\n    BALMeta.lastEarned += earnedBAL;\n\n    // Update the last balance of BAL in the omnipool\n    lastBALBalance = IERC20(BAL).balanceOf(address(omnipool));\n\n    // Emit an event to notify the claimed rewards\n    emit RewardUpdated(earnedBAL);\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Here we perform:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Reward collection via _claimOmnipoolRewards()"}),"\n",(0,a.jsxs)(n.li,{children:["Update of the reward integral (R) for the BAL token. As we can see, ",(0,a.jsx)(n.code,{children:"BALMeta.earnedIntegral"})," represents the earned BAL rewards devided by the total supply of LP tokens (ie. the reward accrued by one unit of LP token)."]}),"\n",(0,a.jsx)(n.li,{children:"Update of the last balance of BAL in the omnipool"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["You probably noticed that ",(0,a.jsx)(n.code,{children:"BALMeta"})," is a struct used to store reward accounting data for a specific token \u2014 in this case, BAL. See the full struct below:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"struct RewardMeta {\n    uint256 earnedIntegral; // a scaled running total of reward per unit of LP token (R)\n    uint256 lastEarned; // the last total amount of reward received\n    mapping(address => uint256) accountIntegral; // the value of R at the time of the user's last update\n    mapping(address => uint256) accountShare; // amount of reward to distribute to the user\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"It stores both global and per-user reward accounting data."}),"\n",(0,a.jsxs)(n.p,{children:["Finally, let's take a look at the ",(0,a.jsx)(n.code,{children:"_updateRewards"})," function, which updates the user's reward share and integral:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"function _updateRewards(address account, uint256 balance) internal {\n    // Get the difference between the global and per-user reward integral (ie. R(t+1) - R(t))\n    uint256 BALIntegralDelta = BALMeta.earnedIntegral - BALMeta.accountIntegral[account];\n\n    // Calculate the amount of reward to distribute to the user\n    uint256 balShare = (balance * BALIntegralDelta) / SCALED_ONE;\n\n    // Update the user's reward share\n    BALMeta.accountShare[account] += balShare;\n\n    // Update the user's reward integral\n    BALMeta.accountIntegral[account] = BALMeta.earnedIntegral;\n\n    // Emit an event to notify the claimed rewards\n    emit RewardUpdated(account, BALIntegralDelta);\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"This logic ensures:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Users only earn rewards for periods where they were actively staked"}),"\n",(0,a.jsx)(n.li,{children:"The reward share is fairly proportional to their balance and holding duration"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The final piece of the puzzle is the ",(0,a.jsx)(n.code,{children:"claimEarnings"})," function. It updates the state of the omnipool and the user, then transfers the accrued rewards to the user's address."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"function claimEarnings() external {\n    // Update the user's reward state\n    updateUserState(msg.sender);\n\n    // Get the share amounts and reset them to 0\n    uint256 balAmount = BALMeta.accountShare[msg.sender];\n    BALMeta.accountShare[msg.sender] = 0;\n\n    // Transfer the rewards to the user\n    BALToken.safeTransferFrom(address(this), msg.sender, balAmount);\n    lastBALBalance = IERC20(BAL).balanceOf(address(this));\n\n    emit RewardClaimed(msg.sender, balAmount);\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You can find the full implementation of the Reward Manager ",(0,a.jsx)(n.a,{href:"https://etherscan.io/address/0xc1094a067b862e57678c4bd5e9d27ed2bd4be937#code",children:"here"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"toward-a-more-concrete-example",children:"Toward a More Concrete Example"}),"\n",(0,a.jsx)(n.p,{children:"Now that you've seen the mathematical model and its implementation, I just wanted to show you a more realistic example to keep in mind."}),"\n",(0,a.jsxs)(n.p,{children:["In the graph below, we represent the evolution of ",(0,a.jsx)(n.code,{children:"R(t)"}),". As you can see, the progression takes the form of a step function. This is because the accrued rewards are only updated from the Reward Manager\u2019s perspective when the corresponding functions are called."]}),"\n",(0,a.jsxs)(n.p,{children:["Additionally, the evolution of ",(0,a.jsx)(n.code,{children:"R(t)"})," is not linear. It depends on both the liquidity of the omnipool and the APRs of the underlying pools that compose it."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Rewards Curve Example",src:t(5643).A+"",width:"1200",height:"800"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"R(t)"})," more realistic evolution. Source Desmos."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"Let's wrap up this article on the inner workings of the Omnipool and the Reward Manager. I hope it helped you gain a better understanding of the Opal protocol and introduced you to some interesting mechanisms you might consider for your own future work. There are other noteworthy components we haven\u2019t covered here, such as the governance module and the rebalancing system\u2014areas I\u2019ve been less involved with. But perhaps that\u2019ll be a good reason to write a second article. See you soon!"})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},7404:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/opal_design-7f73eeb59cedf3229fea96481a5e6e3c.png"},7574:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/reward_curve_user-34b2557c91f402302ea8ea91efd89cbf.png"},8906:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var i=t(6672);const a={},o=i.createContext(a);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(o.Provider,{value:n},e.children)}},9707:e=>{e.exports=JSON.parse('{"permalink":"/clementjuventin-blog/opal-technical-overview","source":"@site/blog/2025-01-23-opal-technical-overview.md","title":"Opal - Technical Overview","description":"In this article, I\u2019ll dive into the technical underpinnings of the Opal protocol, a project I\u2019ve contributed to extensively. If you haven\u2019t yet read the previous article about Opal, I recommend starting there to better understand the context of what follows.","date":"2025-01-23T00:00:00.000Z","tags":[{"inline":false,"label":"Opal","permalink":"/clementjuventin-blog/tags/opal","description":"Opal articles"},{"inline":false,"label":"Technical","permalink":"/clementjuventin-blog/tags/technical","description":"Technical articles"},{"inline":false,"label":"Web3","permalink":"/clementjuventin-blog/tags/web3","description":"Web3 related projects"}],"readingTime":9.83,"hasTruncateMarker":true,"authors":[{"name":"Cl\xe9ment Juventin","title":"Internet traveler \ud83e\udd16\u200b","url":"https://linkedin.com/in/cl\xe9ment-juventin-ab81841a3/","page":{"permalink":"/clementjuventin-blog/authors/clementjuventin"},"socials":{"linkedin":"https://www.linkedin.com/in/clementjuventin/","github":"https://github.com/clementjuventin"},"imageURL":"https://github.com/clementjuventin.png","key":"clementjuventin"}],"frontMatter":{"slug":"opal-technical-overview","title":"Opal - Technical Overview","authors":"clementjuventin","tags":["opal","technical","web3"]},"unlisted":false,"prevItem":{"title":"From A Nooby Degen to a Bloodthirsty Sniper","permalink":"/clementjuventin-blog/degen-to-sniper"},"nextItem":{"title":"My first Open Source Contribution in C++ - EVMOne","permalink":"/clementjuventin-blog/contribution-to-open-source-projects-evmone"}}')}}]);