"use strict";(self.webpackChunkpersonal_website=self.webpackChunkpersonal_website||[]).push([[654],{2360:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var i=n(7410),s=n(3420),r=n(8906);const a={slug:"request-throttler",title:"Tackling Rate Limiting, One of My First Challenges at Cede Labs",authors:"clementjuventin",tags:[]},l=void 0,o={authorsImageUrls:[void 0]},c=[{value:"The Problem: Managing Rate Limits in a Multi-CEX World",id:"the-problem-managing-rate-limits-in-a-multi-cex-world",level:2},{value:"The Solution: Building a Shared Request Throttler",id:"the-solution-building-a-shared-request-throttler",level:2},{value:"The Code: A Deep Dive into the Request Throttler",id:"the-code-a-deep-dive-into-the-request-throttler",level:2},{value:"Key Concepts",id:"key-concepts",level:4},{value:"Prioritization and Background Work",id:"prioritization-and-background-work",level:2},{value:"The Hard Part: Rate Limit Discovery",id:"the-hard-part-rate-limit-discovery",level:2},{value:"Looking Ahead",id:"looking-ahead",level:2}];function d(e){const t={blockquote:"blockquote",code:"code",h2:"h2",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["Cede Labs\u2019 SDK is designed to support any number of centralized exchange accounts, allowing applications or users to query data from several CEXs seamlessly. However, this flexibility exposed a serious issue: ",(0,s.jsx)(t.strong,{children:"API rate limits"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Over the past few weeks at ",(0,s.jsx)(t.strong,{children:"Cede Labs"}),", I\u2019ve been diving deep into the codebase, getting familiar with the SDK, and preparing myself for the complex technical challenges ahead. One of the first major problems I encountered \u2014 and helped solve \u2014 was ",(0,s.jsx)(t.strong,{children:"rate limiting across multiple centralized exchanges (CEXs)"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"the-problem-managing-rate-limits-in-a-multi-cex-world",children:"The Problem: Managing Rate Limits in a Multi-CEX World"}),"\n",(0,s.jsxs)(t.p,{children:["Cede Labs\u2019 SDK is designed to support any number of centralized exchange accounts, allowing applications or users to query data from several CEXs seamlessly. However, this flexibility exposed a serious issue: ",(0,s.jsx)(t.strong,{children:"API rate limits"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["The tricky part is that ",(0,s.jsx)(t.strong,{children:"rate limiting strategies vary widely between exchanges"}),". Some enforce limits by:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"IP address"}),"\n",(0,s.jsx)(t.li,{children:"API key"}),"\n",(0,s.jsx)(t.li,{children:"Master/sub-account hierarchies"}),"\n",(0,s.jsx)(t.li,{children:"Or even combinations of all three"}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["We observed this firsthand through our ",(0,s.jsx)(t.strong,{children:"Chrome extension"}),", which integrates the SDK to interact with multiple exchanges. With many CEX accounts active simultaneously, we were quickly exhausting rate limits, resulting in ",(0,s.jsx)(t.strong,{children:"slowness, API errors, and buggy behavior"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Clearly, we needed a robust, centralized system to handle API throttling across all exchange instances."}),"\n",(0,s.jsx)(t.h2,{id:"the-solution-building-a-shared-request-throttler",children:"The Solution: Building a Shared Request Throttler"}),"\n",(0,s.jsxs)(t.p,{children:["Our SDK uses ",(0,s.jsx)(t.strong,{children:"CCXT"}),", a widely adopted library that simplifies communication with CEX APIs. CCXT conveniently includes built-in metadata about rate limits \u2014 including cost calculations and endpoint-specific constraints \u2014 which became the foundation for our fix."]}),"\n",(0,s.jsxs)(t.p,{children:["I built a component called the ",(0,s.jsx)(t.strong,{children:"Request Throttler"})," to manage all outgoing requests. This module:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Runs a continuous loop, processing a queue of API requests"}),"\n",(0,s.jsx)(t.li,{children:"Delays or batches calls based on calculated rate limits"}),"\n",(0,s.jsx)(t.li,{children:"Shares throttling logic between all exchange instances tied to the same CEX"}),"\n",(0,s.jsx)(t.li,{children:"Supports custom priorities to fast-track high-importance requests"}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"the-code-a-deep-dive-into-the-request-throttler",children:"The Code: A Deep Dive into the Request Throttler"}),"\n",(0,s.jsxs)(t.p,{children:["Below is a simplified version of the throttler's main loop. For readability, I\u2019ve omitted queue-empty handling (i.e., when ",(0,s.jsx)(t.code,{children:"this.getNext()"})," returns ",(0,s.jsx)(t.code,{children:"null"}),")."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"async loop () {\n    let lastTimestamp = now ();\n    while (this.running) {\n        const { resolver, cost, rejecter, timestamp, expireInterval } = this.getNext ();\n\n        if (this.tokens >= 0) {\n            if (timestamp + expireInterval < now ()) {\n                rejecter ('Request expired');\n            } else {\n                this.tokens -= cost;\n                resolver ();\n            }\n            await Promise.resolve ();\n        } else {\n            await sleep (this.delay);\n            const current = now ();\n            const elapsed = current - lastTimestamp;\n            lastTimestamp = current;\n            const tokens = this.tokens + this.refillRate * elapsed;\n            this.tokens = Math.min (tokens, this.capacity);\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(t.h4,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"this.tokens"}),' represents the available request "budget". It\'s reduced by the ',(0,s.jsx)(t.code,{children:"cost"})," of each request."]}),"\n",(0,s.jsxs)(t.li,{children:["If ",(0,s.jsx)(t.code,{children:"this.tokens"})," is below 0, the system will pause (",(0,s.jsx)(t.code,{children:"sleep"}),") and ",(0,s.jsx)(t.strong,{children:"refill"})," tokens based on elapsed time and a configured ",(0,s.jsx)(t.strong,{children:"refill rate"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:["If tokens are available (i.e., ",(0,s.jsx)(t.code,{children:">= 0"}),"), the request is executed ",(0,s.jsx)(t.strong,{children:"only if it hasn't expired"})," (based on ",(0,s.jsx)(t.code,{children:"timestamp + expireInterval"}),")."]}),"\n",(0,s.jsxs)(t.li,{children:["The line ",(0,s.jsx)(t.code,{children:"await Promise.resolve();"})," is a ",(0,s.jsx)(t.strong,{children:"context switch"})," \u2014 it gives other asynchronous tasks a chance to execute, which helps avoid blocking the event loop in JavaScript."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Token refill logic"}),' happens after the delay and simulates a "leaky bucket" or "token bucket" algorithm, a common strategy in rate-limiting systems.']}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"This loop ensures that all API requests respect the configured rate limits by dynamically adjusting based on real-time usage and availability."}),"\n",(0,s.jsx)(t.h2,{id:"prioritization-and-background-work",children:"Prioritization and Background Work"}),"\n",(0,s.jsxs)(t.p,{children:["In practice, our SDK performs a lot of ",(0,s.jsx)(t.strong,{children:"background tasks"}),", such as:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Balance fetching"}),"\n",(0,s.jsx)(t.li,{children:"Historical trade retrieval"}),"\n",(0,s.jsx)(t.li,{children:"Status checks"}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["These operations are necessary but can be expensive in terms of API cost. So, I implemented a ",(0,s.jsx)(t.strong,{children:"priority system"}),": important requests (like user-triggered actions) are associated to high priority while background tasks are associated to low priority."]}),"\n",(0,s.jsx)(t.p,{children:"This ensures faster user experiences without breaking rate limits or starving essential tasks."}),"\n",(0,s.jsx)(t.h2,{id:"the-hard-part-rate-limit-discovery",children:"The Hard Part: Rate Limit Discovery"}),"\n",(0,s.jsxs)(t.p,{children:["The most difficult aspect wasn\u2019t writing the throttler logic itself \u2014 it was understanding and standardizing ",(0,s.jsx)(t.strong,{children:"how each exchange handles rate limits"}),"."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Many rate-limiting rules are hidden, sometimes undocumented and in worse cases not aligned with the official documentation"}),"\n",(0,s.jsx)(t.li,{children:"CCXT\u2019s built-in cost definitions were often outdated"}),"\n",(0,s.jsx)(t.li,{children:"Some CEXs change behavior depending on the account type or endpoint"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"I had to manually test, validate, and correct the API cost values for several exchanges, updating the SDK accordingly."}),"\n",(0,s.jsxs)(t.p,{children:["It also took careful work to ",(0,s.jsx)(t.strong,{children:"share a throttler"})," across multiple CEX instances (i.e., multiple ccxt objects) since each has unique constraints, such as caching behavior or read/write permission separation."]}),"\n",(0,s.jsx)(t.p,{children:"For context:"}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:["A CEX instance in our system is a ",(0,s.jsx)(t.code,{children:"ccxt"})," object tied to a specific API key and access rights. Each instance needs to respect its rate limits but also coordinate with other instances for the same exchange."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"That\u2019s where the Request Throttler comes in \u2014 it sits above the instances and coordinates them like air traffic control."}),"\n",(0,s.jsx)(t.h2,{id:"looking-ahead",children:"Looking Ahead"}),"\n",(0,s.jsx)(t.p,{children:"This was a great first challenge at Cede Labs. It pushed me to go beyond just writing code \u2014 I had to understand CEXs inside out, map inconsistencies, and design a system that works under real-world constraints."}),"\n",(0,s.jsx)(t.p,{children:"There\u2019s still a lot to build and while this system highly reduced our rate limit issues, there is still a lot of improvements to make to reach our goals."}),"\n",(0,s.jsx)(t.p,{children:"I\u2019m proud of how this first technical hurdle turned into a solid foundation for more scalable and reliable SDK behavior."}),"\n",(0,s.jsx)(t.p,{children:"More to come soon!"})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},7410:e=>{e.exports=JSON.parse('{"permalink":"/request-throttler","source":"@site/blog/2024-04-14-request-throttler.md","title":"Tackling Rate Limiting, One of My First Challenges at Cede Labs","description":"Cede Labs\u2019 SDK is designed to support any number of centralized exchange accounts, allowing applications or users to query data from several CEXs seamlessly. However, this flexibility exposed a serious issue: API rate limits.","date":"2024-04-14T00:00:00.000Z","tags":[],"readingTime":4.29,"hasTruncateMarker":true,"authors":[{"name":"Cl\xe9ment Juventin","title":"Internet traveler \ud83e\udd16\u200b","url":"https://linkedin.com/in/cl\xe9ment-juventin-ab81841a3/","page":{"permalink":"/authors/clementjuventin"},"socials":{"linkedin":"https://www.linkedin.com/in/clementjuventin/","github":"https://github.com/clementjuventin"},"imageURL":"https://github.com/clementjuventin.png","key":"clementjuventin"}],"frontMatter":{"slug":"request-throttler","title":"Tackling Rate Limiting, One of My First Challenges at Cede Labs","authors":"clementjuventin","tags":[]},"unlisted":false,"prevItem":{"title":"Opal - Yield DApp built on top of Balancer","permalink":"/opal"},"nextItem":{"title":"I\'m Joining Cede Labs as a Full-Stack Developer!","permalink":"/welcome-to-cede-labs"}}')},8906:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>l});var i=n(6672);const s={},r=i.createContext(s);function a(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);