"use strict";(self.webpackChunkpersonal_website=self.webpackChunkpersonal_website||[]).push([[879],{3476:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/evmone_build-9e838c00b81b0d0ffbfb1bd244253cd5.png"},5686:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});var i=n(6734),o=n(3420),r=n(8906);const s={slug:"contribution-to-open-source-projects-evmone",title:"My first Open Source Contribution in C++ - EVMOne",authors:"clementjuventin",tags:["web3","technical","story"]},a=void 0,l={authorsImageUrls:[void 0]},c=[{value:"The Issue",id:"the-issue",level:2},{value:"Montgomery Modular Multiplication",id:"montgomery-modular-multiplication",level:3},{value:"Fast CIOS Optimization",id:"fast-cios-optimization",level:3},{value:"Implementation",id:"implementation",level:2},{value:"Conclusion",id:"conclusion",level:2}];function m(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["Recently, I decided to learn the ",(0,o.jsx)(t.strong,{children:"C++ programming language"}),". After a few weeks of study, I felt the need to get hands-on experience with professional code by contributing to open source projects. In this article, I\u2019ll walk you through my very first contribution to an open source project: ",(0,o.jsx)(t.strong,{children:"EVMOne"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.a,{href:"https://github.com/ethereum/evmone",children:"EVMOne"})," is an Ethereum Virtual Machine (EVM) implementation written in C++. It can be used as an ",(0,o.jsx)(t.strong,{children:"execution module"})," within other Ethereum clients such as ",(0,o.jsx)(t.a,{href:"https://github.com/ethereum/go-ethereum",children:"Geth"}),". One of the key advantages of EVMOne is its use of C++, a language well-known for its excellent runtime performance. Theoretically, assuming equivalent implementation, EVMOne should offer the ",(0,o.jsx)(t.strong,{children:"best execution performance among EVMs"}),"."]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"Note: I originally planned to wait until my pull request was merged before publishing this article, but as the review is taking longer than expected, I\u2019ve decided to share my experience now."}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"the-issue",children:"The Issue"}),"\n",(0,o.jsxs)(t.p,{children:["To get started with the project, I selected a GitHub issue proposed by the core maintainers:\n",(0,o.jsx)(t.a,{href:"https://github.com/ethereum/evmone/issues/869",children:"Issue #869 \u2013 Implement Fast CIOS for Montgomery Modular Multiplication"}),".\nBefore diving into the implementation, I took time to understand what Montgomery modular multiplication is."]}),"\n",(0,o.jsx)(t.h3,{id:"montgomery-modular-multiplication",children:"Montgomery Modular Multiplication"}),"\n",(0,o.jsxs)(t.p,{children:["Montgomery modular multiplication is an efficient method for computing ",(0,o.jsx)(t.code,{children:"\ud835\udc4e\u22c5\ud835\udc4f mod \ud835\udc41"})," without explicitly performing expensive division operations. Introduced by Peter Montgomery in 1985, it is especially useful in cryptographic algorithms like ",(0,o.jsx)(t.strong,{children:"RSA"})," and ",(0,o.jsx)(t.strong,{children:"elliptic curve cryptography"}),", where many modular multiplications must be performed rapidly."]}),"\n",(0,o.jsx)(t.p,{children:"Instead of working directly with standard modular arithmetic, Montgomery's method transforms numbers into a special form called Montgomery representation, defined as:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"\ud835\udc4e~ = \ud835\udc4e\u22c5\ud835\udc45 mod \ud835\udc41\n"})}),"\n",(0,o.jsx)(t.p,{children:"where \ud835\udc45 is a power of 2 greater than \ud835\udc41, usually chosen as \ud835\udc45=2^\ud835\udc58 for some integer \ud835\udc58, so arithmetic modulo \ud835\udc45 becomes simple bit masking."}),"\n",(0,o.jsxs)(t.p,{children:["The Montgomery product of ",(0,o.jsx)(t.code,{children:"\ud835\udc4e~"})," and ",(0,o.jsx)(t.code,{children:"\ud835\udc4f~"})," is computed as:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"Mont(\ud835\udc4e~, \ud835\udc4f~) = \ud835\udc4e~ \u22c5 \ud835\udc4f~ \u22c5 \ud835\udc45^(-1) mod \ud835\udc41\n"})}),"\n",(0,o.jsx)(t.p,{children:"This yields a result still in Montgomery form. To convert back to the standard representation, a final Montgomery multiplication with 1 is performed."}),"\n",(0,o.jsx)(t.p,{children:"The advantage is that division by \ud835\udc41 is avoided. Instead, the method relies on a series of additions, multiplications, and bit shifts, which are much faster on modern hardware. The \u201cCIOS\u201d (Coarsely Integrated Operand Scanning) method is a particular way of organizing the loop structure of the multiplication to balance performance and code simplicity."}),"\n",(0,o.jsx)(t.h3,{id:"fast-cios-optimization",children:"Fast CIOS Optimization"}),"\n",(0,o.jsxs)(t.p,{children:["In 2022, the paper ",(0,o.jsx)(t.a,{href:"https://eprint.iacr.org/2022/1400.pdf",children:"EdMSM: Multi-Scalar Multiplication for SNARKs and Faster Montgomery Multiplication"})," by ",(0,o.jsx)(t.em,{children:"Gautam Botrel"})," and ",(0,o.jsx)(t.em,{children:"Youssef El Housni"})," introduced a way to optimize the ",(0,o.jsx)(t.strong,{children:"CIOS variant of the Montgomery modular multiplication algorithm"}),". The paper showed that if the most significant bit of the word used in intermediate operations is not required (meaning that all variables stay below ",(0,o.jsx)(t.code,{children:"word_size - 1"}),"), then it\u2019s possible to skip some operations, leading to faster average execution."]}),"\n",(0,o.jsx)(t.p,{children:"This assumption often holds true in practice, making this optimization a worthwhile improvement in many cases."}),"\n",(0,o.jsx)(t.h2,{id:"implementation",children:"Implementation"}),"\n",(0,o.jsx)(t.p,{children:"The process of resolving the issue involved several steps. The first was to understand the structure and conventions of the EVMOne codebase, and to ensure that I could compile and run the project locally."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Project Build",src:n(3476).A+"",width:"1759",height:"210"})}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"Build process for EVMOne."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Once everything was working and all tests passed, I focused on the core of the contribution: the Montgomery algorithm. To fully grasp the optimization, I read several academic papers that detailed the various implementation strategies and explained why the CIOS variant has the lowest computational complexity."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Montgomery Algorithms Variants",src:n(6245).A+"",width:"875",height:"312"})}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:["Different variants of the Montgomery algorithm. Source: ",(0,o.jsx)(t.a,{href:"https://www.microsoft.com/en-us/research/wp-content/uploads/1998/06/97Acar.pdf",children:"High-Speed Algorithms & Architectures For Number-Theoretic Cryptosystems"})," by ",(0,o.jsx)(t.em,{children:"Tolga Acar"}),"."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Next, I located the existing Montgomery implementation within EVMOne and compared it with the optimized CIOS variant described in the research paper."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Montgomery Implementation Comparison",src:n(9641).A+"",width:"2023",height:"887"})}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:["Comparison of the Montgomery implementation in EVMOne with the optimized CIOS variant pseudocode (from ",(0,o.jsx)(t.em,{children:"EdMSM: Multi-Scalar Multiplication for SNARKs and Faster Montgomery Multiplication"}),")."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Finally, I made the necessary code changes to align the implementation with the fast CIOS variant described in the paper:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-cpp",children:"/// Performs a Montgomery modular multiplication.\nconstexpr UintT mul(const UintT& x, const UintT& y) const noexcept\n{\n    constexpr uint64_t most_significant_mod_word_limit{\n        std::numeric_limits<uint64_t>::max() >> 1};\n    constexpr auto S = UintT::num_words;  \n    intx::uint<UintT::num_bits + 64> t;\n    for (size_t i = 0; i != S; ++i)\n    {\n        uint64_t c = 0;\n        for (size_t j = 0; j != S; ++j)\n            std::tie(c, t[j]) = addmul(t[j], x[j], y[i], c);\n   \n        uint64_t carry = 0;\n        if (mod[S - 1] < most_significant_mod_word_limit)\n        { // New branch for Fast CIOS\n            carry = c;\n        }\n        else\n        { \n            auto tmp = intx::addc(t[S], c);\n            t[S] = tmp.value;\n            carry = tmp.carry;\n        }\n        const auto m = t[0] * m_mod_inv;\n        std::tie(c, std::ignore) = addmul(t[0], m, mod[0], 0);\n        for (size_t j = 1; j != S; ++j)\n            std::tie(c, t[j - 1]) = addmul(t[j], m, mod[j], c);\n\n        uint64_t carry = 0;\n        if (mod[S - 1] < most_significant_mod_word_limit)\n        { // New branch for Fast CIOS\n            t[S - 1] = carry + c;\n        }\n        else\n        {\n            auto tmp = intx::addc(t[S], c);\n            t[S - 1] = tmp.value;\n            t[S] = carry + tmp.carry;\n        }\n    }\n    if (t >= mod)\n        t -= mod;\n    return static_cast<UintT>(t);\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:"As you can see, the modifications are relatively minor, consisting mostly of conditional branches that help eliminate unnecessary operations."}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"\u26a0\ufe0f Please note: these changes have not yet been reviewed and may contain errors."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"After a few trials, all unit tests passed, and I was able to run benchmarks on my own machine to evaluate the performance impact."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"Comparing cios_classic.json to cios_improved.json\nBenchmark                                               Time             CPU      Time Old      Time New       CPU Old       CPU New\nevmmax_mul<uint256, bn254>_median                    -0.1529         -0.1529            27            23            27            23\nevmmax_mul<uint256, secp256k1>_median                +0.0059         +0.0058            28            28            28            28\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The results showed a consistent 15% performance improvement on the ",(0,o.jsx)(t.code,{children:"bn254"})," test cases, which aligns with the expectations set by the research.\nIn my most recent comment on the pull request, I mentioned being unsure why two conditional branches performed better than one. Upon further reflection, I believe this may be due to the use of ",(0,o.jsx)(t.code,{children:"constexpr"}),", which allows the compiler to eliminate unused branches at compile-time. Having only one conditional branch introduce more instructions and might prevent such optimizations."]}),"\n",(0,o.jsxs)(t.p,{children:["You can find the pull request ",(0,o.jsx)(t.a,{href:"https://github.com/ethereum/evmone/pull/1009",children:"here"}),"."]}),"\n",(0,o.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(t.p,{children:"As of writing this article, my pull request has not yet been reviewed. Even though the code changes are minimal and early benchmarks support the claims made in the paper, I can\u2019t be fully certain that the proposed implementation will be accepted."}),"\n",(0,o.jsx)(t.p,{children:"This experience has been extremely valuable \u2014 it taught me more about the mathematical tools involved in elliptic curve cryptography and the implementation of the Montgomery algorithm in high-performance environments."}),"\n",(0,o.jsx)(t.p,{children:"I hope this article helped you learn something new as well, and that you enjoyed reading it. See you next time!"})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(m,{...e})}):m(e)}},6245:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/emvone_articles-6022baec0e23a6d32bc87c73013ba10a.png"},6734:e=>{e.exports=JSON.parse('{"permalink":"/clementjuventin-blog/contribution-to-open-source-projects-evmone","source":"@site/blog/2024-10-05-contribution-to-open-source-projects-evmone.md","title":"My first Open Source Contribution in C++ - EVMOne","description":"Recently, I decided to learn the C++ programming language. After a few weeks of study, I felt the need to get hands-on experience with professional code by contributing to open source projects. In this article, I\u2019ll walk you through my very first contribution to an open source project: EVMOne.","date":"2024-10-05T00:00:00.000Z","tags":[{"inline":false,"label":"Web3","permalink":"/clementjuventin-blog/tags/web3","description":"Web3 related projects"},{"inline":false,"label":"Technical","permalink":"/clementjuventin-blog/tags/technical","description":"Technical articles"},{"inline":false,"label":"Story","permalink":"/clementjuventin-blog/tags/story","description":"Story about my life"}],"readingTime":5.73,"hasTruncateMarker":true,"authors":[{"name":"Cl\xe9ment Juventin","title":"Internet traveler \ud83e\udd16\u200b","url":"https://linkedin.com/in/cl\xe9ment-juventin-ab81841a3/","page":{"permalink":"/clementjuventin-blog/authors/clementjuventin"},"socials":{"linkedin":"https://www.linkedin.com/in/clementjuventin/","github":"https://github.com/clementjuventin"},"imageURL":"https://github.com/clementjuventin.png","key":"clementjuventin"}],"frontMatter":{"slug":"contribution-to-open-source-projects-evmone","title":"My first Open Source Contribution in C++ - EVMOne","authors":"clementjuventin","tags":["web3","technical","story"]},"unlisted":false,"prevItem":{"title":"Opal - Technical Overview","permalink":"/clementjuventin-blog/opal-technical-overview"},"nextItem":{"title":"Opal - Yield DApp built on top of Balancer V2","permalink":"/clementjuventin-blog/opal"}}')},8906:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var i=n(6672);const o={},r=i.createContext(o);function s(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:t},e.children)}},9641:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/evmone_compare-97e223f51fe6918f1f81c3dc8d831e50.png"}}]);